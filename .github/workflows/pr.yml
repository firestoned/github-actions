# Copyright (c) 2025 Erick Bourgeois, firestoned
# SPDX-License-Identifier: MIT

name: Test GitHub Actions

on:
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test-rust-cache:
    name: Test rust/cache-cargo
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create test Rust project
        run: |
          cargo init test-project
          cd test-project
          echo 'serde = "1.0"' >> Cargo.toml
          cargo build

      - name: Test cache-cargo action
        uses: ./rust/cache-cargo

      - name: Verify cache was created
        run: |
          echo "Cache should be created for Cargo registry, git index, and build artifacts"

  test-build-library:
    name: Test rust/build-library
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - profile: release
            features: ''
            description: 'Release build with default features'
          - profile: dev
            features: ''
            description: 'Dev build'
          - profile: release
            features: 'serde'
            description: 'Release with specific feature'
    steps:
      - uses: actions/checkout@v4

      - name: Create test library project
        run: |
          cargo init --lib test-library
          cd test-library

          # Replace Cargo.toml with our test configuration
          cat > Cargo.toml <<'EOF'
          [package]
          name = "test-library"
          version = "0.1.0"
          edition = "2021"

          [features]
          default = []
          serde = ["dep:serde"]

          [dependencies]
          serde = { version = "1.0", features = ["derive"], optional = true }
          EOF

          # Create a simple lib.rs
          cat > src/lib.rs <<'EOF'
          #[cfg(feature = "serde")]
          use serde::{Deserialize, Serialize};

          #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
          pub struct TestStruct {
              pub value: i32,
          }

          pub fn add(a: i32, b: i32) -> i32 {
              a + b
          }

          #[cfg(test)]
          mod tests {
              use super::*;

              #[test]
              fn test_add() {
                  assert_eq!(add(2, 2), 4);
              }
          }
          EOF

      - name: Build library (${{ matrix.description }})
        id: build
        run: |
          cd test-library

          # Use the build-library action from parent directory
          echo "Building with profile: ${{ matrix.profile }}, features: ${{ matrix.features }}"

          if [ "${{ matrix.profile }}" = "release" ]; then
            if [ -n "${{ matrix.features }}" ]; then
              cargo build --release --lib --features "${{ matrix.features }}" --verbose
            else
              cargo build --release --lib --verbose
            fi
          else
            cargo build --lib --verbose
          fi

          echo "status=success" >> $GITHUB_OUTPUT

      - name: Verify build artifacts
        run: |
          cd test-library

          # Check that library was built
          if [ "${{ matrix.profile }}" = "release" ]; then
            ls -la target/release/
            test -f target/release/libtest_library.rlib || { echo "ERROR: Library not found"; exit 1; }
            echo "✓ Release library found"
          else
            ls -la target/debug/
            test -f target/debug/libtest_library.rlib || { echo "ERROR: Library not found"; exit 1; }
            echo "✓ Debug library found"
          fi

          echo "✓ Library build verified for ${{ matrix.description }}"

  test-lint:
    name: Test rust/lint
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - test-case: 'well-formatted'
            should-pass: true
            description: 'Well formatted code should pass'
          - test-case: 'badly-formatted'
            should-pass: false
            description: 'Badly formatted code should fail'
          - test-case: 'clippy-warnings'
            should-pass: false
            description: 'Code with clippy warnings should fail'
    steps:
      - uses: actions/checkout@v4

      - name: Create test project
        run: |
          cargo init --lib test-lint
          cd test-lint

          # Create Cargo.toml with features
          cat > Cargo.toml <<'EOF'
          [package]
          name = "test-lint"
          version = "0.1.0"
          edition = "2021"

          [features]
          default = []
          serde = ["dep:serde"]

          [dependencies]
          serde = { version = "1.0", features = ["derive"], optional = true }
          EOF

      - name: Create well-formatted code
        if: matrix.test-case == 'well-formatted'
        run: |
          cd test-lint
          cat > src/lib.rs <<'EOF'
          #[cfg(feature = "serde")]
          use serde::{Deserialize, Serialize};

          #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
          pub struct TestStruct {
              pub value: i32,
          }

          pub fn add(a: i32, b: i32) -> i32 {
              a + b
          }

          #[cfg(test)]
          mod tests {
              use super::*;

              #[test]
              fn test_add() {
                  assert_eq!(add(2, 2), 4);
              }
          }
          EOF

      - name: Create badly-formatted code
        if: matrix.test-case == 'badly-formatted'
        run: |
          cd test-lint
          cat > src/lib.rs <<'EOF'
          pub fn add(a:i32,b:i32)->i32{a+b}
          pub fn multiply( a : i32 , b : i32 ) -> i32 { a * b }
          EOF

      - name: Create code with clippy warnings
        if: matrix.test-case == 'clippy-warnings'
        run: |
          cd test-lint
          cat > src/lib.rs <<'EOF'
          pub fn add(a: i32, b: i32) -> i32 {
              a + b
          }

          // Clippy will warn about this
          pub fn unused_variable() {
              let x = 42;  // unused variable
          }

          // Clippy will warn about this
          pub fn needless_return(x: i32) -> i32 {
              return x + 1;  // needless return
          }
          EOF

      - name: Run lint (${{ matrix.description }})
        id: lint
        continue-on-error: true
        run: |
          cd test-lint

          # Simulate the lint action behavior
          echo "Running cargo fmt --check..."
          FMT_RESULT=0
          cargo fmt --all --check || FMT_RESULT=$?

          echo "Running cargo clippy..."
          CLIPPY_RESULT=0
          cargo clippy --all-targets -- -D warnings || CLIPPY_RESULT=$?

          if [ $FMT_RESULT -ne 0 ] || [ $CLIPPY_RESULT -ne 0 ]; then
            echo "Lint failed as expected for ${{ matrix.test-case }}"
            exit 1
          else
            echo "Lint passed"
            exit 0
          fi

      - name: Verify expected result
        run: |
          LINT_EXIT_CODE=${{ steps.lint.outcome }}

          if [ "${{ matrix.should-pass }}" = "true" ]; then
            if [ "$LINT_EXIT_CODE" = "success" ]; then
              echo "✓ Test passed: ${{ matrix.description }}"
            else
              echo "✗ Test failed: Expected success but got failure"
              exit 1
            fi
          else
            if [ "$LINT_EXIT_CODE" = "failure" ]; then
              echo "✓ Test passed: ${{ matrix.description }}"
            else
              echo "✗ Test failed: Expected failure but got success"
              exit 1
            fi
          fi

      - name: Test lint action directly (well-formatted only)
        if: matrix.test-case == 'well-formatted'
        working-directory: test-lint
        run: |
          # Test the individual commands that the action would run
          echo "Testing cargo fmt --check..."
          cargo fmt --all --check

          echo "Testing cargo clippy..."
          cargo clippy --all-targets -- -D warnings

          echo "✓ Lint action commands work correctly"

  test-extract-version:
    name: Test versioning/extract-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        workflow-type: [main, pr, release]
    steps:
      - uses: actions/checkout@v4

      - name: Test extract-version (main)
        if: matrix.workflow-type == 'main'
        id: version-main
        uses: ./versioning/extract-version
        with:
          repository: firestoned/test-repo
          workflow-type: main

      - name: Test extract-version (pr)
        if: matrix.workflow-type == 'pr'
        id: version-pr
        uses: ./versioning/extract-version
        with:
          repository: firestoned/test-repo
          workflow-type: pr
          pr-number: 42

      - name: Test extract-version (release)
        if: matrix.workflow-type == 'release'
        id: version-release
        uses: ./versioning/extract-version
        with:
          repository: firestoned/test-repo
          workflow-type: release
          release-tag: v1.2.3

      - name: Display version outputs
        run: |
          echo "Workflow type: ${{ matrix.workflow-type }}"
          if [ "${{ matrix.workflow-type }}" = "main" ]; then
            echo "Version: ${{ steps.version-main.outputs.version }}"
            echo "Tag: ${{ steps.version-main.outputs.tag-name }}"
            echo "Image Tag: ${{ steps.version-main.outputs.image-tag }}"
            echo "Image Repo: ${{ steps.version-main.outputs.image-repository }}"
            echo "Short SHA: ${{ steps.version-main.outputs.short-sha }}"
          elif [ "${{ matrix.workflow-type }}" = "pr" ]; then
            echo "Version: ${{ steps.version-pr.outputs.version }}"
            echo "Tag: ${{ steps.version-pr.outputs.tag-name }}"
            echo "Image Tag: ${{ steps.version-pr.outputs.image-tag }}"
            echo "Image Repo: ${{ steps.version-pr.outputs.image-repository }}"
          elif [ "${{ matrix.workflow-type }}" = "release" ]; then
            echo "Version: ${{ steps.version-release.outputs.version }}"
            echo "Tag: ${{ steps.version-release.outputs.tag-name }}"
            echo "Image Tag: ${{ steps.version-release.outputs.image-tag }}"
            echo "Image Repo: ${{ steps.version-release.outputs.image-repository }}"
          fi

  test-license-check:
    name: Test security/license-check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create test files
        run: |
          mkdir -p test-files

          # Create Rust file with SPDX header
          cat > test-files/test.rs <<'EOF'
          // Copyright (c) 2025 Test Author
          // SPDX-License-Identifier: MIT

          fn main() {
              println!("Hello");
          }
          EOF

          # Create Shell script with SPDX header
          cat > test-files/test.sh <<'EOF'
          #!/usr/bin/env bash
          # Copyright (c) 2025 Test Author
          # SPDX-License-Identifier: MIT

          echo "Hello"
          EOF

      - name: Test license-check action
        uses: ./security/license-check
        with:
          copyright-holder: 'Test Author'
          license-id: MIT

  test-docker-setup:
    name: Test docker/setup-docker
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Test setup-docker action
        uses: ./docker/setup-docker
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify Docker Buildx
        run: |
          docker buildx version
          docker buildx ls

  test-verify-signed-commits:
    name: Test security/verify-signed-commits
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Test verify-signed-commits (PR mode)
        uses: ./security/verify-signed-commits
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          verify-mode: pr
          base-ref: origin/main
        continue-on-error: true  # Don't fail if commits aren't signed in test

  test-actions-validity:
    name: Validate Action Syntax
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate all action.yml files
        run: |
          echo "Checking for action.yml files..."
          find . -name "action.yml" -o -name "action.yaml" | while read action; do
            echo "Validating: $action"
            # Basic YAML syntax check
            python3 -c "import yaml; yaml.safe_load(open('$action'))" || exit 1
            echo "✓ $action is valid"
          done

      - name: Check for required fields
        run: |
          echo "Checking for required fields in actions..."
          find . -name "action.yml" -o -name "action.yaml" | while read action; do
            echo "Checking: $action"

            # Check for name
            grep -q "^name:" "$action" || { echo "ERROR: Missing 'name' in $action"; exit 1; }

            # Check for description
            grep -q "^description:" "$action" || { echo "ERROR: Missing 'description' in $action"; exit 1; }

            # Check for runs.using
            grep -q "using:" "$action" || { echo "ERROR: Missing 'runs.using' in $action"; exit 1; }

            echo "✓ $action has required fields"
          done

  test-documentation:
    name: Validate Documentation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for README files
        run: |
          echo "Checking for README.md files..."

          # Check that every action has a README
          find . -name "action.yml" -o -name "action.yaml" | while read action; do
            dir=$(dirname "$action")
            if [ ! -f "$dir/README.md" ]; then
              echo "ERROR: Missing README.md in $dir"
              exit 1
            else
              echo "✓ Found README.md in $dir"
            fi
          done

      - name: Validate README content
        run: |
          echo "Checking README content..."

          find . -type f -name "README.md" \( -path "*/rust/*" -o -path "*/security/*" -o -path "*/docker/*" -o -path "*/versioning/*" \) | while read readme; do
            echo "Checking: $readme"

            # Check for required sections
            grep -q "## Usage" "$readme" || grep -q "## Quick Start" "$readme" || { echo "ERROR: Missing Usage section in $readme"; exit 1; }
            grep -q "## Features" "$readme" || { echo "WARNING: Missing Features section in $readme"; }
            grep -q "## License" "$readme" || { echo "WARNING: Missing License section in $readme"; }

            echo "✓ $readme has required sections"
          done

  test-licensing:
    name: Validate License Headers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check SPDX headers in action files
        run: |
          echo "Checking SPDX headers in action.yml files..."

          find . -name "action.yml" -o -name "action.yaml" | while read action; do
            if ! head -n 10 "$action" | grep -q "SPDX-License-Identifier:"; then
              echo "ERROR: Missing SPDX header in $action"
              exit 1
            else
              echo "✓ $action has SPDX header"
            fi
          done

      - name: Check for LICENSE file
        run: |
          if [ ! -f "LICENSE" ]; then
            echo "ERROR: Missing LICENSE file in repository root"
            exit 1
          else
            echo "✓ LICENSE file exists"
          fi
