# Copyright (c) 2025 Erick Bourgeois, firestoned
# SPDX-License-Identifier: MIT

name: Test GitHub Actions

on:
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test-rust-cache:
    name: Test rust/cache-cargo
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create test Rust project
        run: |
          cargo init test-project
          cd test-project
          echo 'serde = "1.0"' >> Cargo.toml
          cargo build

      - name: Test cache-cargo action
        uses: ./rust/cache-cargo

      - name: Verify cache was created
        run: |
          echo "Cache should be created for Cargo registry, git index, and build artifacts"

  test-build-library:
    name: Test rust/build-library
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - profile: release
            features: ''
            description: 'Release build with default features'
          - profile: dev
            features: ''
            description: 'Dev build'
          - profile: release
            features: 'serde'
            description: 'Release with specific feature'
    steps:
      - uses: actions/checkout@v4

      - name: Create test library project
        run: |
          cargo init --lib test-library
          cd test-library

          # Replace Cargo.toml with our test configuration
          cat > Cargo.toml <<'EOF'
          [package]
          name = "test-library"
          version = "0.1.0"
          edition = "2021"

          [features]
          default = []
          serde = ["dep:serde"]

          [dependencies]
          serde = { version = "1.0", features = ["derive"], optional = true }
          EOF

          # Create a simple lib.rs
          cat > src/lib.rs <<'EOF'
          #[cfg(feature = "serde")]
          use serde::{Deserialize, Serialize};

          #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
          pub struct TestStruct {
              pub value: i32,
          }

          pub fn add(a: i32, b: i32) -> i32 {
              a + b
          }

          #[cfg(test)]
          mod tests {
              use super::*;

              #[test]
              fn test_add() {
                  assert_eq!(add(2, 2), 4);
              }
          }
          EOF

      - name: Build library (${{ matrix.description }})
        id: build
        run: |
          cd test-library

          # Use the build-library action from parent directory
          echo "Building with profile: ${{ matrix.profile }}, features: ${{ matrix.features }}"

          if [ "${{ matrix.profile }}" = "release" ]; then
            if [ -n "${{ matrix.features }}" ]; then
              cargo build --release --lib --features "${{ matrix.features }}" --verbose
            else
              cargo build --release --lib --verbose
            fi
          else
            cargo build --lib --verbose
          fi

          echo "status=success" >> $GITHUB_OUTPUT

      - name: Verify build artifacts
        run: |
          cd test-library

          # Check that library was built
          if [ "${{ matrix.profile }}" = "release" ]; then
            ls -la target/release/
            test -f target/release/libtest_library.rlib || { echo "ERROR: Library not found"; exit 1; }
            echo "✓ Release library found"
          else
            ls -la target/debug/
            test -f target/debug/libtest_library.rlib || { echo "ERROR: Library not found"; exit 1; }
            echo "✓ Debug library found"
          fi

          echo "✓ Library build verified for ${{ matrix.description }}"

  test-lint:
    name: Test rust/lint
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - test-case: 'well-formatted'
            should-pass: true
            description: 'Well formatted code should pass'
          - test-case: 'badly-formatted'
            should-pass: false
            description: 'Badly formatted code should fail'
          - test-case: 'clippy-warnings'
            should-pass: false
            description: 'Code with clippy warnings should fail'
    steps:
      - uses: actions/checkout@v4

      - name: Create test project
        run: |
          cargo init --lib test-lint
          cd test-lint

          # Create Cargo.toml with features
          cat > Cargo.toml <<'EOF'
          [package]
          name = "test-lint"
          version = "0.1.0"
          edition = "2021"

          [features]
          default = []
          serde = ["dep:serde"]

          [dependencies]
          serde = { version = "1.0", features = ["derive"], optional = true }
          EOF

      - name: Create well-formatted code
        if: matrix.test-case == 'well-formatted'
        run: |
          cd test-lint
          cat > src/lib.rs <<'EOF'
          #[cfg(feature = "serde")]
          use serde::{Deserialize, Serialize};

          #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
          pub struct TestStruct {
              pub value: i32,
          }

          pub fn add(a: i32, b: i32) -> i32 {
              a + b
          }

          #[cfg(test)]
          mod tests {
              use super::*;

              #[test]
              fn test_add() {
                  assert_eq!(add(2, 2), 4);
              }
          }
          EOF

      - name: Create badly-formatted code
        if: matrix.test-case == 'badly-formatted'
        run: |
          cd test-lint
          cat > src/lib.rs <<'EOF'
          pub fn add(a:i32,b:i32)->i32{a+b}
          pub fn multiply( a : i32 , b : i32 ) -> i32 { a * b }
          EOF

      - name: Create code with clippy warnings
        if: matrix.test-case == 'clippy-warnings'
        run: |
          cd test-lint
          cat > src/lib.rs <<'EOF'
          pub fn add(a: i32, b: i32) -> i32 {
              a + b
          }

          // Clippy will warn about this
          pub fn unused_variable() {
              let x = 42;  // unused variable
          }

          // Clippy will warn about this
          pub fn needless_return(x: i32) -> i32 {
              return x + 1;  // needless return
          }
          EOF

      - name: Run lint (${{ matrix.description }})
        id: lint
        continue-on-error: true
        run: |
          cd test-lint

          # Simulate the lint action behavior
          echo "Running cargo fmt --check..."
          FMT_RESULT=0
          cargo fmt --all --check || FMT_RESULT=$?

          echo "Running cargo clippy..."
          CLIPPY_RESULT=0
          cargo clippy --all-targets -- -D warnings || CLIPPY_RESULT=$?

          if [ $FMT_RESULT -ne 0 ] || [ $CLIPPY_RESULT -ne 0 ]; then
            echo "Lint failed as expected for ${{ matrix.test-case }}"
            exit 1
          else
            echo "Lint passed"
            exit 0
          fi

      - name: Verify expected result
        run: |
          LINT_EXIT_CODE=${{ steps.lint.outcome }}

          if [ "${{ matrix.should-pass }}" = "true" ]; then
            if [ "$LINT_EXIT_CODE" = "success" ]; then
              echo "✓ Test passed: ${{ matrix.description }}"
            else
              echo "✗ Test failed: Expected success but got failure"
              exit 1
            fi
          else
            if [ "$LINT_EXIT_CODE" = "failure" ]; then
              echo "✓ Test passed: ${{ matrix.description }}"
            else
              echo "✗ Test failed: Expected failure but got success"
              exit 1
            fi
          fi

      - name: Test lint action directly (well-formatted only)
        if: matrix.test-case == 'well-formatted'
        working-directory: test-lint
        run: |
          # Test the individual commands that the action would run
          echo "Testing cargo fmt --check..."
          cargo fmt --all --check

          echo "Testing cargo clippy..."
          cargo clippy --all-targets -- -D warnings

          echo "✓ Lint action commands work correctly"

  test-extract-version:
    name: Test versioning/extract-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        workflow-type: [main, pr, release]
    steps:
      - uses: actions/checkout@v4

      - name: Test extract-version (main)
        if: matrix.workflow-type == 'main'
        id: version-main
        uses: ./versioning/extract-version
        with:
          repository: firestoned/test-repo
          workflow-type: main

      - name: Test extract-version (pr)
        if: matrix.workflow-type == 'pr'
        id: version-pr
        uses: ./versioning/extract-version
        with:
          repository: firestoned/test-repo
          workflow-type: pr
          pr-number: 42

      - name: Test extract-version (release)
        if: matrix.workflow-type == 'release'
        id: version-release
        uses: ./versioning/extract-version
        with:
          repository: firestoned/test-repo
          workflow-type: release
          release-tag: v1.2.3

      - name: Display version outputs
        run: |
          echo "Workflow type: ${{ matrix.workflow-type }}"
          if [ "${{ matrix.workflow-type }}" = "main" ]; then
            echo "Version: ${{ steps.version-main.outputs.version }}"
            echo "Tag: ${{ steps.version-main.outputs.tag-name }}"
            echo "Image Tag: ${{ steps.version-main.outputs.image-tag }}"
            echo "Image Repo: ${{ steps.version-main.outputs.image-repository }}"
            echo "Short SHA: ${{ steps.version-main.outputs.short-sha }}"
          elif [ "${{ matrix.workflow-type }}" = "pr" ]; then
            echo "Version: ${{ steps.version-pr.outputs.version }}"
            echo "Tag: ${{ steps.version-pr.outputs.tag-name }}"
            echo "Image Tag: ${{ steps.version-pr.outputs.image-tag }}"
            echo "Image Repo: ${{ steps.version-pr.outputs.image-repository }}"
          elif [ "${{ matrix.workflow-type }}" = "release" ]; then
            echo "Version: ${{ steps.version-release.outputs.version }}"
            echo "Tag: ${{ steps.version-release.outputs.tag-name }}"
            echo "Image Tag: ${{ steps.version-release.outputs.image-tag }}"
            echo "Image Repo: ${{ steps.version-release.outputs.image-repository }}"
          fi

  test-license-check:
    name: Test security/license-check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create test files
        run: |
          mkdir -p test-files

          # Create Rust file with SPDX header
          cat > test-files/test.rs <<'EOF'
          // Copyright (c) 2025 Test Author
          // SPDX-License-Identifier: MIT

          fn main() {
              println!("Hello");
          }
          EOF

          # Create Shell script with SPDX header
          cat > test-files/test.sh <<'EOF'
          #!/usr/bin/env bash
          # Copyright (c) 2025 Test Author
          # SPDX-License-Identifier: MIT

          echo "Hello"
          EOF

      - name: Test license-check action
        uses: ./security/license-check
        with:
          copyright-holder: 'Test Author'
          license-id: MIT

  test-docker-setup:
    name: Test docker/setup-docker
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Test setup-docker action
        uses: ./docker/setup-docker
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify Docker Buildx
        run: |
          docker buildx version
          docker buildx ls

  test-verify-signed-commits:
    name: Test security/verify-signed-commits
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Test verify-signed-commits (PR mode)
        uses: ./security/verify-signed-commits
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          verify-mode: pr
          base-ref: origin/main
        continue-on-error: true  # Don't fail if commits aren't signed in test

  test-actions-validity:
    name: Validate Action Syntax
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate all action.yml files
        run: |
          echo "Checking for action.yml files..."
          find . -name "action.yml" -o -name "action.yaml" | while read action; do
            echo "Validating: $action"
            # Basic YAML syntax check
            python3 -c "import yaml; yaml.safe_load(open('$action'))" || exit 1
            echo "✓ $action is valid"
          done

      - name: Check for required fields
        run: |
          echo "Checking for required fields in actions..."
          find . -name "action.yml" -o -name "action.yaml" | while read action; do
            echo "Checking: $action"

            # Check for name
            grep -q "^name:" "$action" || { echo "ERROR: Missing 'name' in $action"; exit 1; }

            # Check for description
            grep -q "^description:" "$action" || { echo "ERROR: Missing 'description' in $action"; exit 1; }

            # Check for runs.using
            grep -q "using:" "$action" || { echo "ERROR: Missing 'runs.using' in $action"; exit 1; }

            echo "✓ $action has required fields"
          done

  test-documentation:
    name: Validate Documentation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for README files
        run: |
          echo "Checking for README.md files..."

          # Check that every action has a README
          find . -name "action.yml" -o -name "action.yaml" | while read action; do
            dir=$(dirname "$action")
            if [ ! -f "$dir/README.md" ]; then
              echo "ERROR: Missing README.md in $dir"
              exit 1
            else
              echo "✓ Found README.md in $dir"
            fi
          done

      - name: Validate README content
        run: |
          echo "Checking README content..."

          find . -type f -name "README.md" \( -path "*/rust/*" -o -path "*/security/*" -o -path "*/docker/*" -o -path "*/versioning/*" \) | while read readme; do
            echo "Checking: $readme"

            # Check for required sections
            grep -q "## Usage" "$readme" || grep -q "## Quick Start" "$readme" || { echo "ERROR: Missing Usage section in $readme"; exit 1; }
            grep -q "## Features" "$readme" || { echo "WARNING: Missing Features section in $readme"; }
            grep -q "## License" "$readme" || { echo "WARNING: Missing License section in $readme"; }

            echo "✓ $readme has required sections"
          done

  test-licensing:
    name: Validate License Headers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check SPDX headers in action files
        run: |
          echo "Checking SPDX headers in action.yml files..."

          find . -name "action.yml" -o -name "action.yaml" | while read action; do
            if ! head -n 10 "$action" | grep -q "SPDX-License-Identifier:"; then
              echo "ERROR: Missing SPDX header in $action"
              exit 1
            else
              echo "✓ $action has SPDX header"
            fi
          done

      - name: Check for LICENSE file
        run: |
          if [ ! -f "LICENSE" ]; then
            echo "ERROR: Missing LICENSE file in repository root"
            exit 1
          else
            echo "✓ LICENSE file exists"
          fi

  test-setup-rust-build:
    name: Test rust/setup-rust-build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target:
          - x86_64-unknown-linux-gnu
          - aarch64-unknown-linux-gnu
    steps:
      - uses: actions/checkout@v4

      - name: Test setup-rust-build with ${{ matrix.target }}
        uses: ./rust/setup-rust-build
        with:
          target: ${{ matrix.target }}

      - name: Verify Rust installation
        run: |
          rustc --version
          cargo --version
          if rustup target list --installed | grep -q ${{ matrix.target }}; then
            echo "✓ Target ${{ matrix.target }} installed"
          else
            echo "✗ Target ${{ matrix.target }} NOT installed"
            echo "Installed targets:"
            rustup target list --installed
            exit 1
          fi

      - name: Verify default components
        run: |
          rustfmt --version
          cargo clippy --version

      - name: Verify cross for ARM64
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          cross --version

  test-setup-rust-build-custom-components:
    name: Test rust/setup-rust-build with custom components
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Test setup-rust-build with custom components
        uses: ./rust/setup-rust-build
        with:
          target: x86_64-unknown-linux-gnu
          components: llvm-tools-preview

      - name: Verify custom component
        run: |
          # llvm-tools-preview gets installed as llvm-tools-<triple>
          if rustup component list --installed | grep -q llvm-tools; then
            echo "✓ llvm-tools component installed"
            rustup component list --installed | grep llvm-tools
          else
            echo "✗ llvm-tools component NOT installed"
            echo "Installed components:"
            rustup component list --installed
            exit 1
          fi

  test-build-binary:
    name: Test rust/build-binary
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target:
          - x86_64-unknown-linux-gnu
    steps:
      - uses: actions/checkout@v4

      - name: Create test binary project
        run: |
          cargo init test-binary
          cd test-binary
          cat > src/main.rs <<'EOF'
          fn main() {
              println!("Hello from test binary!");
          }
          EOF

      - name: Setup Rust
        uses: ./rust/setup-rust-build
        with:
          target: ${{ matrix.target }}

      - name: Test build-binary action
        working-directory: test-binary
        run: |
          cargo build --release --target ${{ matrix.target }} --verbose

      - name: Verify binary was built
        run: |
          cd test-binary
          test -f target/${{ matrix.target }}/release/test-binary
          echo "✓ Binary built successfully"
          ./target/${{ matrix.target }}/release/test-binary

  test-verify-toolchain:
    name: Test rust/verify-toolchain
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: ./rust/setup-rust-build
        with:
          target: x86_64-unknown-linux-gnu

      - name: Test verify-toolchain (cargo only)
        uses: ./rust/verify-toolchain
        with:
          require-cargo: true

      - name: Test verify-toolchain (cargo + rustfmt + clippy)
        id: verify-all
        uses: ./rust/verify-toolchain
        with:
          require-cargo: true
          require-rustfmt: true
          require-clippy: true

      - name: Verify outputs
        run: |
          echo "Rustc version: ${{ steps.verify-all.outputs.rustc-version }}"
          echo "Cargo version: ${{ steps.verify-all.outputs.cargo-version }}"
          echo "Rustfmt version: ${{ steps.verify-all.outputs.rustfmt-version }}"
          echo "Clippy version: ${{ steps.verify-all.outputs.clippy-version }}"

          # Check that outputs are not empty
          test -n "${{ steps.verify-all.outputs.rustc-version }}"
          test -n "${{ steps.verify-all.outputs.cargo-version }}"
          test -n "${{ steps.verify-all.outputs.rustfmt-version }}"
          test -n "${{ steps.verify-all.outputs.clippy-version }}"

  test-verify-toolchain-missing:
    name: Test rust/verify-toolchain (should fail when component missing)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust without llvm-tools
        uses: ./rust/setup-rust-build
        with:
          target: x86_64-unknown-linux-gnu
          components: ''  # Install without any extra components

      - name: Test verify-toolchain requiring missing component
        id: verify
        uses: ./rust/verify-toolchain
        with:
          require-cargo: true
          require-llvm-tools: true  # This should fail since we didn't install it
        continue-on-error: true

      - name: Verify it failed as expected
        run: |
          if [ "${{ steps.verify.outcome }}" = "failure" ]; then
            echo "✓ Test passed: verify-toolchain correctly failed when llvm-tools-preview is not installed"
          else
            echo "✗ Test failed: verify-toolchain should have failed when required component is missing"
            echo "Outcome was: ${{ steps.verify.outcome }}"
            exit 1
          fi

  test-generate-sbom:
    name: Test rust/generate-sbom
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - describe: crate
            format: json
            test-case: 'Single crate, JSON format'
          - describe: crate
            format: xml
            test-case: 'Single crate, XML format'
          - describe: binaries
            format: json
            test-case: 'Binaries mode'
    steps:
      - uses: actions/checkout@v4

      - name: Create test project
        run: |
          cargo init test-sbom
          cd test-sbom
          cat > Cargo.toml <<'EOF'
          [package]
          name = "test-sbom"
          version = "0.1.0"
          edition = "2021"

          [dependencies]
          serde = { version = "1.0", features = ["derive"] }
          EOF

      - name: Setup Rust
        uses: ./rust/setup-rust-build
        with:
          target: x86_64-unknown-linux-gnu

      - name: Test generate-sbom (${{ matrix.test-case }})
        working-directory: test-sbom
        run: |
          # Install cargo-cyclonedx
          cargo install cargo-cyclonedx --version 0.5.7

          # Generate SBOM
          cargo cyclonedx --describe ${{ matrix.describe }} --format ${{ matrix.format }} --all

      - name: Verify SBOM files
        run: |
          cd test-sbom
          if [ "${{ matrix.format }}" = "json" ]; then
            if compgen -G "*.cdx.json" > /dev/null 2>&1; then
              ls -lh *.cdx.json
            elif compgen -G "test-sbom_*.cdx.json" > /dev/null 2>&1; then
              ls -lh test-sbom_*.cdx.json
            else
              echo "No JSON SBOM found"
              exit 1
            fi
          else
            if compgen -G "*.cdx.xml" > /dev/null 2>&1; then
              ls -lh *.cdx.xml
            elif compgen -G "test-sbom_*.cdx.xml" > /dev/null 2>&1; then
              ls -lh test-sbom_*.cdx.xml
            else
              echo "No XML SBOM found"
              exit 1
            fi
          fi

  test-generate-sbom-workspace:
    name: Test rust/generate-sbom with workspace
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create test workspace
        run: |
          mkdir test-workspace
          cd test-workspace

          # Create workspace Cargo.toml
          cat > Cargo.toml <<'EOF'
          [workspace]
          members = ["crate-a", "crate-b"]
          resolver = "2"
          EOF

          # Create crate-a
          cargo init --lib crate-a
          cat > crate-a/Cargo.toml <<'EOF'
          [package]
          name = "crate-a"
          version = "0.1.0"
          edition = "2021"

          [dependencies]
          serde = "1.0"
          EOF

          # Create crate-b
          cargo init --lib crate-b
          cat > crate-b/Cargo.toml <<'EOF'
          [package]
          name = "crate-b"
          version = "0.1.0"
          edition = "2021"

          [dependencies]
          crate-a = { path = "../crate-a" }
          EOF

      - name: Setup Rust
        uses: ./rust/setup-rust-build
        with:
          target: x86_64-unknown-linux-gnu

      - name: Test generate-sbom for workspace
        working-directory: test-workspace
        run: |
          # Install cargo-cyclonedx
          cargo install cargo-cyclonedx --version 0.5.7

          # Generate SBOM for entire workspace
          # Note: cargo-cyclonedx 0.5.7 uses --all instead of --workspace
          cargo cyclonedx --all --describe crate --format json

      - name: Verify workspace SBOMs
        run: |
          cd test-workspace
          echo "Searching for SBOMs in workspace..."

          # Check root
          if compgen -G "*.cdx.json" > /dev/null 2>&1; then
            echo "Root SBOMs:"
            for file in *.cdx.json; do
              ls -lh "$file"
            done
          fi

          # Check each crate
          find . -name "*.cdx.json" -not -path "*/target/*" -type f | while read sbom; do
            echo "Found SBOM: $sbom"
          done

          # Ensure at least one SBOM was created
          sbom_count=$(find . -name "*.cdx.json" -not -path "*/target/*" -type f | wc -l | tr -d ' ')
          if [ "$sbom_count" -eq 0 ]; then
            echo "ERROR: No SBOMs found"
            exit 1
          fi
          echo "✓ Found $sbom_count SBOM(s)"

  test-security-scan:
    name: Test rust/security-scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Create test project
        run: |
          cargo init test-security
          cd test-security
          cat > Cargo.toml <<'EOF'
          [package]
          name = "test-security"
          version = "0.1.0"
          edition = "2021"

          [dependencies]
          serde = "1.0"
          EOF

      - name: Setup Rust
        uses: ./rust/setup-rust-build
        with:
          target: x86_64-unknown-linux-gnu

      - name: Test security-scan action
        working-directory: test-security
        run: |
          # Install cargo-audit
          cargo install cargo-audit --version 0.21.0

          # Run audit (may or may not find vulnerabilities)
          cargo audit || true

          echo "✓ Security scan completed"

  test-trivy-scan:
    name: Test security/trivy-scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build test container image
        run: |
          cat > Dockerfile <<'EOF'
          FROM alpine:3.18
          RUN apk add --no-cache curl
          CMD ["/bin/sh"]
          EOF
          docker build -t test-image:latest .

      - name: Test trivy-scan action
        uses: ./security/trivy-scan
        with:
          image-ref: test-image:latest
          format: table
          exit-code: 0
        continue-on-error: true

      - name: Verify trivy ran
        run: |
          echo "✓ Trivy scan completed"

  test-trivy-scan-sarif:
    name: Test security/trivy-scan with SARIF output
    runs-on: ubuntu-latest
    permissions:
      security-events: write
    steps:
      - uses: actions/checkout@v4

      - name: Build test container image
        run: |
          cat > Dockerfile <<'EOF'
          FROM alpine:3.18
          RUN apk add --no-cache curl
          CMD ["/bin/sh"]
          EOF
          docker build -t test-image-sarif:latest .

      - name: Test trivy-scan with SARIF
        uses: ./security/trivy-scan
        with:
          image-ref: test-image-sarif:latest
          format: sarif
          output: trivy-results.sarif
          sarif-category: trivy-container-test
        continue-on-error: true

      - name: Verify SARIF output
        run: |
          if [ -f "trivy-results.sarif" ]; then
            echo "✓ SARIF file created"
            cat trivy-results.sarif | jq . > /dev/null || { echo "ERROR: Invalid SARIF JSON"; exit 1; }
          else
            echo "ERROR: SARIF file not found"
            exit 1
          fi

  test-cosign-sign:
    name: Test security/cosign-sign (keyless)
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Build and tag test image
        run: |
          cat > Dockerfile <<'EOF'
          FROM alpine:3.18
          CMD ["/bin/sh"]
          EOF
          docker build -t ghcr.io/test/test-image:test .

      - name: Test cosign-sign action (dry run simulation)
        run: |
          # Install cosign
          curl -LO https://github.com/sigstore/cosign/releases/download/v2.2.0/cosign-linux-amd64
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
          sudo chmod +x /usr/local/bin/cosign

          # Verify cosign is installed
          cosign version

          echo "✓ Cosign installation verified"
          echo "Note: Actual signing requires OIDC token and push permissions to registry"
